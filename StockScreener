import yfinance as yf
import pandas as pd
import numpy as np
import statsmodels.api as sm
from scipy import stats
from datetime import datetime, timedelta
import warnings

 # all factors taken from the global factor study listed below:
 # https://jkpfactors.com/

# --- SILENCE WARNINGS ---
warnings.simplefilter(action='ignore', category=FutureWarning)
warnings.simplefilter(action='ignore', category=UserWarning)

# --- CONFIGURATION ---
# Using the same tickers as your screenshot
TICKERS = [
    "AMZN", "AAPL", "MSFT", "GOOGL", "META", "TSLA", "NVDA", "JPM", "V", "JNJ",
    "WMT", "PG", "DIS", "MA", "HD", "BAC", "XOM", "PFE", "KO", "CSCO", "ADBE",
    "NFLX", "INTC", "CMCSA", "T", "PEP", "ABNB", "CRM", "ORCL", "COST", "NKE"
]

# "BIL" is the SPDR Bloomberg 1-3 Month T-Bill ETF. 
# "SGOV" is the iShares 0-3 Month Treasury Bond ETF.
# It is the standard tradable proxy for the Risk-Free Rate.
RISK_FREE_TICKER = "SGOV" 

START_DATE = (datetime.now() - timedelta(days=365*4)).strftime("%Y-%m-%d") 
END_DATE = datetime.now().strftime("%Y-%m-%d")

def get_financial_factors(ticker):
    stock = yf.Ticker(ticker)
    fin = stock.financials.T
    bs = stock.balance_sheet.T
    cf = stock.cashflow.T
    
    dfs = [d for d in [fin, bs, cf] if not d.empty]
    if not dfs: return None
    
    fund_df = pd.concat(dfs, axis=1)
    fund_df.index = pd.to_datetime(fund_df.index)
    fund_df = fund_df.sort_index()
    
        # --- FACTORS ---
            
    # Fator List:
    # 1 F_Sales_Inv: Change in Sales minus Change in Inventory (scaled by Assets)
    # 2 F_Price_High_Inv: Inverted Price to 52-Week High
    # 3 F_Momentum: Price Momentum (t-1 to t-9)
    # 4 F_Tax_Surprise: Change in Tax Expense scaled by Assets
    # 6 F_OCF: Change in Operating Cash Flow scaled by Assets


    # 1. Change Sales minus Change Inventory (scaled by Assets)
    # Logic: A higher value indicates sales are outpacing inventory buildup (Bullish signal).
    try:
        rev = fund_df['Total Revenue'] if 'Total Revenue' in fund_df else fund_df['TotalRevenue']
        inv = fund_df['Inventory'] if 'Inventory' in fund_df else pd.Series(0, index=fund_df.index)
        assets = fund_df['Total Assets'] if 'Total Assets' in fund_df else fund_df['TotalAssets']
        assets_lag = assets.shift(1)
        
        d_sales = rev.diff()
        d_inv = inv.diff()
        fund_df['F_Sales_Inv'] = (d_sales - d_inv) / assets_lag
    except:
        fund_df['F_Sales_Inv'] = np.nan

    # 6. Change in Operating Cash Flow / Assets
    #Logic: Measures the acceleration of cash generation. Increasing cash flow relative to the firm's asset base is generally a strong quality signal.
    try:
        ocf = fund_df['Operating Cash Flow'] if 'Operating Cash Flow' in fund_df else fund_df['TotalCashFromOperatingActivities']
        d_ocf = ocf.diff()
        fund_df['F_OCF'] = d_ocf / assets_lag
    except:
        fund_df['F_OCF'] = np.nan

    # 3. Tax Expense Surprise
    # Logic: An increase in tax expense often implies higher taxable income, which can be a proxy for genuine profitability that is harder to manipulate than Net Income.
    # I think it is catching firms that are being made to pay more taxes because of legislation -> lower margins -> bad
    try:
        tax = fund_df['Tax Provision'] if 'Tax Provision' in fund_df else fund_df['TaxProvision']
        d_tax = tax.diff()
        fund_df['F_Tax_Surprise'] = d_tax / assets_lag
    except:
        fund_df['F_Tax_Surprise'] = np.nan
        
    return fund_df[['F_Sales_Inv', 'F_OCF', 'F_Tax_Surprise']]

def get_risk_free_returns():
    print(f"Fetching Risk-Free Rate ({RISK_FREE_TICKER})...")
    try:
        df = yf.download(RISK_FREE_TICKER, start=START_DATE, end=END_DATE, progress=False, auto_adjust=False)
        
        if isinstance(df.columns, pd.MultiIndex):
            try: df = df.xs(RISK_FREE_TICKER, level=1, axis=1)
            except: df = df.iloc[:, :5]

        # Use Adj Close to capture the interest payments (dividends)
        col_name = 'Adj Close' if 'Adj Close' in df.columns else 'Close'
        
        rf_monthly = df[[col_name]].resample('ME').last()
        rf_monthly['Rf'] = rf_monthly[col_name].pct_change().shift(-1)
        
        return rf_monthly[['Rf']]
    except Exception as e:
        print(f"Error fetching Risk Free Rate: {e}")
        return pd.DataFrame()

def build_dataset(tickers):
    rf_df = get_risk_free_returns()
    if rf_df.empty: rf_df = pd.DataFrame(columns=['Rf'])

    print(f"Building Panel Dataset for {len(tickers)} tickers (might take a while)...")
    panel_data = []
    
    for t in tickers:
        try:
            df_price = yf.download(t, start=START_DATE, end=END_DATE, progress=False, auto_adjust=False)
            if df_price.empty: continue
            
            if isinstance(df_price.columns, pd.MultiIndex):
                try: df_price = df_price.xs(t, level=1, axis=1)
                except: df_price = df_price.iloc[:, :5]
            
            price_col = 'Adj Close' if 'Adj Close' in df_price.columns else 'Close'
            df_price = df_price[[price_col]]
            df_price.columns = ['Close']

            df_m = df_price.resample('ME').last()
            
 

            # 2. INVERTED Price to 52-Week High (Buy the Dip)
            # Logic: Compares current price to the 52-week high.
            # Multiplying by -1 "inverts" it: stocks furthest from their high (the "dip") 
            # get higher scores in this specific model's logic.
            rolling_max = df_price['Close'].rolling(252).max()
            rolling_max_monthly = rolling_max.resample('ME').last()
            df_m['F_Price_High_Inv'] = (df_m['Close'] / rolling_max_monthly) * -1 

            # 3. Momentum (t-1 to t-9)
            # Logic: Standard "short-term" momentum. 
            # It measures the return from 9 months ago to 1 month ago.
            # We shift(1) to avoid "short-term reversal" (the tendency for last week's winners to dip). 
            df_m['F_Momentum'] = (df_m['Close'].shift(1) / df_m['Close'].shift(9)) - 1

            df_fund = get_financial_factors(t)
            
            if df_fund is not None:
                df_m = df_m.sort_index()
                df_fund = df_fund.sort_index()
                df_final = pd.merge_asof(df_m, df_fund, left_index=True, right_index=True, direction='backward')
                df_final = df_final.ffill(limit=12)
            else:
                df_final = df_m
                df_final[['F_Sales_Inv', 'F_OCF', 'F_Tax_Surprise']] = np.nan

            # C. Target: Excess Return
            df_final['Raw_Ret'] = df_final['Close'].pct_change().shift(-1)
            df_final = df_final.join(rf_df, how='left')
            df_final['Rf'] = df_final['Rf'].fillna(0.0)
            df_final['Excess_Ret'] = df_final['Raw_Ret'] - df_final['Rf']
            
            df_final['Ticker'] = t
            df_final = df_final.reset_index()
            if 'Date' not in df_final.columns: df_final = df_final.rename(columns={'index': 'Date'})
            
            panel_data.append(df_final)
            
        except:
            continue

    return pd.concat(panel_data).dropna()

def run_refined_regression():
    # Cross-sectional normalization to prevent outliers from skewing results
    df = build_dataset(TICKERS)
    if df.empty: return

    factor_cols = ['F_Price_High_Inv', 'F_Sales_Inv', 'F_OCF', 'F_Momentum', 'F_Tax_Surprise']
    
    for col in factor_cols:
        df[col] = df.groupby('Date')[col].transform(lambda x: (x - x.mean()) / x.std())
    
    df = df.dropna()

    r_squared_values = []
    coefficients = []
    
    print(f"\nRunning Regression on {len(df)} observations...")
    
    for date, group in df.groupby('Date'):
        if len(group) < 8: continue 
        
        Y = group['Excess_Ret']
        X = group[factor_cols]
        X = sm.add_constant(X)
        
        try:
            model = sm.OLS(Y, X).fit()
            r_squared_values.append(model.rsquared_adj) 
            coeffs = model.params.to_dict()
            coeffs['Date'] = date
            coefficients.append(coeffs)
        except:
            pass

    if not r_squared_values:
        print("Not enough valid data points.")
        return

    avg_r2 = np.mean(r_squared_values)
    
    coeff_df = pd.DataFrame(coefficients).set_index('Date')
    stats_df = pd.DataFrame()
    
    stats_df['Premium'] = coeff_df[factor_cols].mean()
    se = coeff_df[factor_cols].std() / np.sqrt(len(coeff_df))
    stats_df['t-stat'] = stats_df['Premium'] / se
    
    df_resid = len(coeff_df) - 1
    stats_df['p-value'] = 2 * (1 - stats.t.cdf(np.abs(stats_df['t-stat']), df=df_resid))
    
    pd.set_option('display.float_format', '{:.6f}'.format)
    
    print("\n" + "="*70)
    print(f"FULL MODEL PERFORMANCE (Avg Adj R-Squared): {avg_r2:.4f} ({avg_r2*100:.2f}%)")
    print("="*70)
    print(f"Risk-Free Ticker Used: {RISK_FREE_TICKER} from {START_DATE} to {END_DATE}")
    print(stats_df)
    print("-" * 70)
    

if __name__ == "__main__":
    run_refined_regression()